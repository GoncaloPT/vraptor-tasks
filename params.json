{"name":"Vraptor-tasks","body":"Tasks\r\n======\r\n\r\nThis plugin allows your Vraptor application to schedule jobs to be executed using a specified interval or cron expression.\r\n\r\nInstallation \r\n--------\r\n\r\n1. \tIn a Maven project's pom.xml file:\r\n\r\n```xml \r\n <repositories>\r\n    <repository>\r\n        <id>sonatype-oss-public</id>\r\n        <url>https://oss.sonatype.org/content/groups/public/</url>\r\n        <releases>\r\n            <enabled>true</enabled>\r\n        </releases>\r\n        <snapshots>\r\n        \t<enabled>true</enabled>\r\n\t    </snapshots>\r\n    </repository>\r\n</repositories> \r\n\r\n<dependency>\r\n  \t<groupId>br.com.prixma</groupId>\r\n  \t<artifactId>vraptor-tasks</artifactId>\r\n  \t<version>1.0.1</version>\r\n</dependency>\r\n```\r\n  \r\nSimple Task \r\n--------   \r\n```java\r\n@PrototypeScoped\r\n@Scheduled(fixedRate = 30000)\r\npublic class ReportsDelivery implements Task {\r\n\r\n\tprivate Mailer mailer;\r\n\tprivate ScheduledReports reports;\r\n\t\t\r\n\tReportsDelivery(Mailer mailer, ScheduledReports reports){\r\n\t\tthis.mailer = mailer;\r\n\t\tthis.reports = reports;\r\n\t}\r\n\t\r\n\tpublic void execute() {\r\n\t\tfor(Email email : reports.toDeliver()){\r\n\t\t\tmailer.send(email);\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\r\nTransactional Task (Hibernate)\r\n--------\r\n```java\r\nimport br.com.caelum.vraptor.tasks.jobs.hibernate.TransactionalTask;\r\n\t\r\n@PrototypeScoped\r\n@Scheduled(cron = \"* * 0/12 * * ?\")\r\npublic class DatabaseDumper implements TransactionalTask {\r\n\r\n\tprivate Database database;\r\n\r\n\tpublic void execute() {\r\n\t\tdatabase.backup();\r\n\t}\r\n\r\n\tpublic void setup(Session session, Validator validator) {\r\n\t\tdatabase = new Database(session);\r\n\t}\r\n}\r\n```\r\n\r\nTransactional Task (JPA)\r\n--------\r\n```java\r\nimport br.com.caelum.vraptor.tasks.jobs.jpa.TransactionalTask;\r\n\t\r\n@PrototypeScoped\r\n@Scheduled(cron = \"* * 0/12 * * ?\")\r\npublic class DatabaseDumper implements TransactionalTask {\r\n\r\n\tprivate Database database;\r\n\r\n\tpublic void execute() {\r\n\t\tdatabase.backup();\r\n\t}\r\n\r\n\tpublic void setup(EntityManager manager, Validator validator) {\r\n\t\tdatabase = new Database(manager);\r\n\t}\r\n}\r\n```\r\n\r\nBean Validation (JSR303)\t\r\n--------\r\n\r\nTo use these features you only need to put any implementation of Bean Validation jars in your classpath.\r\nIf validation fails the transaction will not be effective. \r\n\r\n```java\r\nimport br.com.caelum.vraptor.tasks.jobs.jpa.TransactionalTask;\r\nimport br.com.caelum.vraptor.tasks.validator.Validator;\r\n\t\r\n@PrototypeScoped\r\n@Scheduled(fixedRate = 60000)\r\npublic class CsvImporter implements TransactionalTask {\r\n\r\n\tprivate ClientRepository repository;\r\n\tprivate Validator validator;\r\n\tprivate CsvFile file = ...\r\n\r\n\tpublic void execute() {\r\n\t\tif(file.exists()){\r\n\t\t\twhile(file.hasNext()){\r\n\t\t\t\tClient client = (Client) file.next();\r\n\t\t\t\tvalidator.validate(client);\r\n\t\t\t\trepository.add(client);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void setup(EntityManager manager, Validator validator) {\r\n\t\tthis.repository = new ClientRepository(manager);\r\n\t\tthis.validator = validator;\r\n\t}\r\n}\r\n```\r\n```java\r\n\r\n@Entity\r\npublic class client {\r\n\t\r\n\t@Id\r\n\t@GeneratedValue\r\n\tprivate Long id;\r\n\r\n\t@CreditCardNumber\r\n\tprivate String creditCard;\r\n\t...\r\n\r\n```\r\n\r\nManual Scheduling\r\n--------\r\n1. \tRemove @Scheduled annotation\r\n2. \tCreate the following component: \r\n\t\r\n```java\t\r\n@Component\r\n@ApplicationScoped\r\npublic class CustomScheduler {\r\n\r\n\tpublic CustomScheduler(TaskScheduler scheduler, List<Task> tasks){\r\n\t\tfor(Task task : tasks){\r\n\t\t\tscheduler.schedule(task, customTrigger());\r\n\t\t}\r\n\t}\r\n}\r\n```\r\n\t\r\nTasks and Request Scope\r\n--------\r\n\r\nIf you need to access components with request scope, the easiest way is to build your logic into a method of a controller and call it from a task.\r\nThere´s a helper class (TaskRequest) that does it for you. This class finds the path for your method dynamically and performs a get request.\r\n\r\n```java\r\n@ApplicationScoped\r\n@Scheduled(fixedRate = 5000)\r\npublic class RequestScopeTask implements Task {\r\n\r\n\tprivate final TaskRequest request;\r\n\t\r\n\tpublic RequestScopeTask(TaskRequest request) {\r\n\t\tthis.request = request;\r\n\t}\r\n\r\n\tpublic void execute() {\r\n\t\trequest.access(Controller.class).method();\r\n\t\tif(request.sucess())\r\n\t\t\tlog something...\r\n\t}\r\n}\r\n```\r\n\r\n```java\t\r\n@Resource\r\npublic class Controller {\r\n\t\r\n\tprivate RequestComponent component;\r\n\t\t\r\n\tController(RequestComponent component){\r\n\t\tthis.component = component;\r\n\t}\r\n\t\r\n\t@Get(\"task/execute\")\r\n\tpublic void method(){\r\n\t\t//put task logic here\r\n\t}\r\n}\r\n```\r\n\t\r\nIf you want to block requests from outside the server, there´s a solution here: <https://gist.github.com/1312993>\r\n\r\nStateful Tasks\r\n--------\r\n\r\nBy default, Quartz jobs are stateless, resulting in the possibility of jobs interfering with each other. It might be possible that before the first job has finished, the second one will start. \r\nTo make tasks non-concurrent, set the concurrent flag to false. This flag ensures that job execution doesn't overlap.\r\nExample:\r\n\r\n```java\r\n@Scheduled(fixedRate = 30000, concurrent = false)\r\npublic class BatchImporter implements Task {\r\n\r\n\tpublic void execute() {\r\n\t\t...\r\n\t}\r\n}\r\n```\r\n\r\nControlling Tasks\r\n--------\r\n\r\nOk, your tasks are scheduled, but sometimes you need control them manually. No problem:\r\n\r\n```java\t\r\n@Resource\r\npublic class TaskController {\r\n\t\r\n\tprivate TaskExecutor executor;\r\n\r\n\tTaskController(TaskExecutor executor){\r\n\t\tthis.executor = executor;\r\n\t}\r\n\t\r\n\t@Path(\"task/execute\")\r\n\tvoid execute(){\r\n\t\texecutor.execute(MyTask.class); //execute it now!\r\n\t}\r\n\r\n\t@Path(\"task/pause\")\r\n\tvoid pause(){\r\n\t\texecutor.pause(MyTask.class); //pause associated trigger, no more executions!\r\n\t}\r\n\t\r\n\t@Path(\"...\")\r\n\tvoid resume(Task task){\r\n\t\texecutor.resume(task); //un-pause associated trigger\r\n\t}\r\n\t\r\n\t@Path(\"tasks/pause\")\r\n\tvoid pauseAll(){\r\n\t\texecutor.pauseAll(); //pause all triggers (put scheduler in 'remembering' mode)\r\n\t\t//all new tasks will be paused as they are added\r\n\t}\r\n\t\r\n\t@Path(\"tasks/resume\")\r\n\tvoid resumeAll(){\r\n\t\texecutor.resumeAll(); //un-pause all triggers\r\n\t}\r\n}\r\n```\r\n\r\nMonitoring Tasks \r\n--------\r\n```java\r\n@Resource\r\npublic class TasksController {\r\n\r\n\tpublic TasksController(TasksMonitor monitor) {\r\n\t\tTaskStatistics stats = monitor.getStatisticsFor(MyTask.class);\r\n\t\tlog.debug(\"Fire Time: {}\", stats.getFireTime());\r\n\t\tlog.debug(\"Scheduled Fire Time: {}\", stats.getScheduledFireTime());\r\n\t\tlog.debug(\"Next Fire Time: {}\", stats.getNextFireTime());\r\n\t\tlog.debug(\"Previous Fire Time: {}\", stats.getPreviousFireTime());\r\n\t\tlog.debug(\"Execution Time: {}\", stats.getExecutionTime());\r\n\t\tlog.debug(\"Max Execution Time: {}\", stats.getMaxExecutionTime());\r\n\t\tlog.debug(\"Min Execution Time: {}\", stats.getMinExecutionTime());\r\n\t\tlog.debug(\"Execution Count: {}\", stats.getExecutionCount());\r\n\t\tlog.debug(\"Refire Count: {}\", stats.getRefireCount());\r\n\t\tlog.debug(\"Fail Count: {}\", stats.getFailCount());\r\n\t\tlog.debug(\"Last Fault: {}\", stats.getLastException());\r\n\t}\r\n}\r\n```\t\r\n\r\nMore information?\r\n\r\n```java\r\n@Component\r\npublic class TaskEventLogger implements TaskCallback {\r\n\r\n\tpublic void executed(Class task, TaskStatistics stats){ ... }\r\n\t\r\n\tpublic void scheduled(Class task, Trigger trigger){ ... }\r\n\t\r\n\tpublic void unscheduled(Class task){ ... }\r\n\t\r\n\tpublic void failed(Class task, TaskStatistics stats, Exception error){ ... }\r\n\t\r\n\tpublic void paused(Class task){ ... }\r\n\t\r\n\tpublic void resumed(Class task){ ... }\r\n\t\r\n\tpublic void beforeExecute(Class task){ ... }\r\n\t\r\n\tpublic void executionVetoed(Class task){ ... }\r\n\t\r\n\t...\r\n}\r\n```\t\r\n\r\nCreating Custom Tasks \r\n--------\r\n\r\nTo create custom tasks: \r\n\r\n1.\tCreate an interface that extends `br.com.caelum.vraptor.tasks.Task`\r\n\r\n```java\r\npublic interface InterruptableTask extends Task {\r\n\tvoid interrupt(); \t\r\n}\r\n```\t\r\n\r\n2.\tCreate a class that decorate the execution of its task (must implement `org.quartz.Job`)\r\n\r\n```java\r\npublic class InterruptableJobWrapper implements InterruptableJob {\r\n\r\n\tprivate final InterruptableTask delegate;\r\n\r\n\tpublic InterruptableJobWrapper(InterruptableTask delegate) {\r\n\t\tthis.delegate = delegate;\r\n\t}\r\n\r\n\tpublic void execute(JobExecutionContext context) throws JobExecutionException {\r\n\t\tdelegate.execute();\r\n\t}\r\n\r\n\tpublic void interrupt() throws UnableToInterruptJobException {\r\n\t\tdelegate.interrupt();\r\n\t}\r\n}\r\n```\r\n\r\n3.\tCreate a class that provides its task (must implement `br.com.caelum.vraptor.tasks.jobs.JobProvider`)\r\n\r\n```java\r\n@Component\r\n@ApplicationScoped\r\npublic class InterruptableTaskProvider implements JobProvider {\r\n\r\n\t//Should only instantiate your custom job\r\n\tpublic boolean canProvide(Class<? extends Job> job) {\r\n\t\treturn InterruptableJobWrapper.class.equals(job);\r\n\t}\r\n\t\r\n\t//Should only decorate your custom task\r\n\tpublic boolean canDecorate(Class<? extends Task> task) {\r\n\t\treturn InterruptableTask.class.isAssignableFrom(task);\r\n\t}\r\n\t\r\n\t//Register your wrapper \r\n\tpublic Class<? extends Job> getJobWrapper() {\r\n\t\treturn InterruptableJobWrapper.class;\r\n\t}\r\n\t\r\n\t//Delegates the execution to your wrapper\r\n\tpublic Job newJob(Task task) {\r\n\t\treturn new InterruptableJobWrapper((InterruptableTask) task);\r\n\t}\r\n\r\n}\r\n```\r\n\r\n4.\tNow we are ready to do some cool task\r\n\r\n```java\r\n@ApplicationScoped\r\n@Scheduled(fixedRate = 60000)\r\npublic class RuntimeProcessTask implements InterruptableTask {\r\n\t\r\n\tprivate final Runtime runtime;\r\n\t\r\n\tpublic RuntimeProcessTask(Runtime runtime) {\r\n\t\tthis.runtime = runtime;\r\n\t}\r\n\r\n\tpublic void execute() {\r\n\t\truntime.exec(\"ping www.google.com\");\r\n\t}\r\n\r\n\tpublic void interrupt() {\r\n\t\truntime.kill();\r\n\t}\r\n}\r\n```\r\n\r\nLicense\r\n--------\r\nCopyright (c) 2011 William Pivotto\r\nAll rights reserved.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); \r\nyou may not use this file except in compliance with the License. \r\nYou may obtain a copy of the License at \r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0 \r\n\r\nUnless required by applicable law or agreed to in writing, software \r\ndistributed under the License is distributed on an \"AS IS\" BASIS, \r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. \r\nSee the License for the specific language governing permissions and \r\nlimitations under the License.","tagline":"This plugin adds Quartz job scheduling features to Vraptor application","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}